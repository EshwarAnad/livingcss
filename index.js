/**
 * A section of the style guide.
 * @typedef {object} Section
 * @property {string} name - Name of the section.
 * @property {string} description -  Description of the section. Will be processed as markdown.
 * @property {string} id - Section id (generated by hyphenating the section name).
 * @property {Section[]} children - List of child sections.
 */

var fs = require('fs');
var glob = require('glob');
var Handlebars = require('handlebars');
var marked = require('marked');
var minify = require('html-minifier').minify;
var Promise = require("native-promise-only");
var parser = require('comment-parser');
var PARSERS = parser.PARSERS;
var firstLineRe = /^[^\n\r]+/;
var whiteSpaceRe = / /g;

var tags = {

  /**
   * Add a new section to the style guide.
   *
   * The @section tag can define the section name or the first line of the description will be
   * used as the section name.
   *
   * @example
      /**
       * My Section
       *
       * A description of the section and how to use it.
       *
       * @section
       *\/

       /**
       * A description of the section and how to use it.
       *
       * @section My Section
       *\/
   */
  section: function (tag, comment, block, sections) {
    var name, description;

    // @section did not define the name so use the first line of the block description
    // as the section name and use the rest as the section description
    if (!tag.description) {
      name = comment.description.match(firstLineRe)[0];
      description = comment.description.substr(comment.name.length).replace(/^[\n\r]+/, '');
    }
    // @section defined the name so use the comment description as the section description
    else {
      name = tag.description;
      description = comment.description;
    }

    block.name = name;
    block.description = marked(description);
    block.id = getId(name);

    sections.push(block);
  },

  /**
   * Identify a section as a child of another section.
   *
   * @example
      /**
       * A description of the parent section.
       *
       * @section Parent Section
       *\/

      /**
       * A description of the child section.
       *
       * @section Child Section
       * @sectionof Parent Section
       *\/
   */
  sectionof: function(tag, comment, block, sections) {
    for (var i = 0, section; section = sections[i]; i++) {
      if (section.name === tag.description) {
        block.parent = section.name;

        section.children = section.children || [];
        section.children.push(block);

        return;
      }
    }
  }
};

/**
 * Get an id by hyphen separating the name
 *
 * @param {string} str - String to hyphenate.
 * @returns {string}
 */
function getId(str) {
  return str.toLowerCase().replace(whiteSpaceRe, '-');
}

/**
 *
 */
function readFileGlobs(patterns, callback) {
  return new Promise(function(resolve, reject) {
    patterns.forEach(function(pattern, index) {

      glob(pattern, function(err, files) {
        if (err) {
          reject(err);
        }

        readFiles(files, callback).then(function() {

          // all files have been read
          if (index === patterns.length - 1) {
            resolve();
          }
        });

      });

    });

  });
}

/**
 *
 */
function readFiles(files, callback) {
  return new Promise(function(resolve, reject) {
    files.forEach(function(file, index) {

      fs.readFile(file, 'utf8', function(err, data) {
        if (err) {
          reject(err);
        }

        callback(data, file);

        // all files have been read
        if (index === files.length - 1) {
          resolve();
        }
      });

    });

  });
}





/**
 * Generate a style guide using content driven content creation.
 *
 * @param {string|string[]} source=[] - List of glob files.
 * @param {string} dest - Name of the file for the generated HTML.
 * @param {object} [options={}] - Configuration options.
 * @param {string} [options.template="defaultTempalte.hbs"] - Path to the handlebars template to use for generating the HTML.
 * @param {string|string[]} [options.partials=[]] - List of paths to handlebars partial files used in the template.
 * @param {string[]} [options.sectionOrder=[]] - List of the sort order for all root sections (a section without a parent). Any section not listed will be added to the end in the order encountered.
 * @param {object} [options.tags] - Custom tags and their callback functions to parse them. The function will receive the current tag, current parsed comment block, and the list of sections as parameters.
 * @param {boolean} [options.minify=true] - If the generated HTML should be minified.
 */
function styleGuideGenerator(source, dest, options) {
  if (!(this instanceof styleGuideGenerator)) {
    return new styleGuideGenerator(source, dest, options);
  }

  var _this = this;

  // @property {Section[]} sections - List of sections defined in the file.
  this.sections = [];

  // @property {object} tags - Tags and their callback function.
  this.tags = tags;

  // defaults
  source = (typeof source === 'string' ? [source] : source);
  options = options || {};
  options.template = options.template || 'defaultTempalte.hbs';
  // TODO: fix to take string or array
  options.partials = options.partials || [];
  options.sectionOrder = options.sectionOrder || [];
  options.minify = (typeof options.minify === 'undefined' ? true : options.minify);

  // normalize sort order section names
  options.sectionOrder.forEach(function(value, index) {
    options[index] = value.toLowerCase();
  });

  // get all source files
  readFileGlobs(source, this.parseComments.bind(this))
    .then(function() {
      return _this.loadPartials(options);
    })
    .then(function() {
      _this.generate(options);
    })
    .catch(function(err) {
      console.log('err:', err);
    });
};

/**
 * Load handlebar partials.
 */
styleGuideGenerator.prototype.loadPartials = function(options) {
  var _this = this;

  // no partials to load
  if (options.partials.length === 0) {
    // console.log('Promise.resolve():', Promise.resolve());
    return Promise.resolve();
  }

  return readFileGlobs(options.partials, function(data, path) {
    // the name of the partial will be the filename
    var name = path.slice(path.lastIndexOf('/') + 1, file.lastIndexOf('.'));

    Handlebars.registerPartial(name, data);
  });
};

/**
 * Parse file comments.
 *
 * @param {string} file - Contents of the file.
 */
styleGuideGenerator.prototype.parseComments = function(file) {
  var _this = this;

  // since we aren't processing any @param like comments we can skip parsing the name
  // to get the description to be the full tag
  // @see https://github.com/yavorskiy/comment-parser/issues/19
  var comments = parser(file, {
    parsers: [
      PARSERS.parse_tag,
      PARSERS.parse_type,
      function (str, data) {
        return null;
      },
      PARSERS.parse_description
    ],
    trim: false
  });

  // parse comments
  comments.forEach(function(comment, index) {
    var block = {};

    // parse tags
    for (var i = 0, tag; tag = comment.tags[i]; i++) {
      // tag is defined
      if (_this.tags[tag.tag]) {
        _this.tags[tag.tag](tag, comment, block, _this.sections);
      }
      // any tag that is not defined will just be parsed and added to the block as a property
      else {
        block[tag.tag] = tag.description;
      }
    }
  });
};

/**
 * Generate an HTML page.
 *
 * @param {object} options - Configuration options.
 */
styleGuideGenerator.prototype.generate = function(options) {
  // find all root sections (sections with no parent)
  var rootSections = this.sections.filter(function(section) {
    return !section.parent;
  });

  console.log('rootSections:', rootSections);

  // sort root sections by section order
  rootSections.sort(function(a, b) {
    var aIndex = options.sectionOrder.indexOf(a.name.toLowerCase());
    var bIndex = options.sectionOrder.indexOf(b.name.toLowerCase());

    // default sections not in the section order to the bottom of the stack
    if (aIndex === -1) {
      return 1;
    }
    else if (bIndex === -1) {
      return -1;
    }

    return aIndex - bIndex;
  });

  // allow users to modify the sections before being passed to handlebars
  var context = { sections: rootSections };

  // if (options.preProcess)

  fs.readFile(options.template, 'utf8', function(err, data) {
    if (err) {
      throw err;
    }

    var template = Handlebars.compile(data);

    html = template(context);

    if (!options.minify) {
      html = minify(html, {
        collapseWhitespace: true
      });
    }

    // output the file
    console.log('context:', context);
  });
};

module.exports = styleGuideGenerator;